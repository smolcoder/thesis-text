\chapter{Описание реализованного подхода}
\label{chapter2}

В данной главе описывается разработанный метод улучшения существующих подходов к решению задачи автотегирования методами ближайших соседей.

\section{Постановка задачи}
Целью данной работы является улучшение алгоритмов ближайших соседей. Требования к данной работе:
\begin{itemize}
 \item Разработать метод улучшения существующих алгоритмов на основе перехода от песни к ее исполнителю;
 \item Провести сравнение разработанного метода с существующими state-of-the-art методами на множестве русских песен;
 \item Апробировать предложенный подход для фильтрации похожих исполнителей в музыкальных рекомендациях социальной сети ``Одноклассники''.
\end{itemize}

В данной работе сделан акцент именно на русскую музыку, так как имеется достаточно много исследований, которые проверялись на зарубежной (в основном, англоязычной) музыке.

\section{Переход от песни к исполнителю}

В главе \ref{chapter1} были описаны два основных алгоритма, основанных на методе ближайших соседей: взвешенный k-NN (k Nearest Neighbors) и CBDC (Class-based Distance Classifier).
Также были отмечены сильные и слабые стороны каждого из них в задачах сопоставления тегов песне и поиску песен по тегу. Но оба этих метода используют для тегирования конкретной песни
информацию только о ней самой. Предлагаемый метод лишен этого недостатка. Приведем сначала общее, затем формальное описание метода.

\subsection{Общее описание}

Здесь и далее \emph{исполнителем} будем называть артиста, группу, квартет, трио \ld группу из одного или более людей, исполняющих музыку в одном коллективе.

Наверняка каждый из нас нередко угадывал исполнителя по впервые услышанной песне. Иногда даже достаточно прослушать короткий ее отрывок. Почему так получается? 
Что именно позволяет нам понять, кто исполняет песню? 
Сформулируем несколько наблюдений, которые помогут нам ответить на эти вопросы:
\begin{itemize}
 \item песни конкретного исполнителя как правило принадлежат одному и тому же жанру (или ограниченному множеству жанров);
 \item конкретный исполнитель поет одним и тем же голосом;
 \item в мелодиях разных песен конкретного исполнителя присутствуют одни и те же (или похожие на слух) \emph{сэмплы} и т.д.
\end{itemize}
Разумеется, это всего лишь наблюдения, которые верны хоть и в большинстве случаев, но не во всех. Тем не менее они кажутся вполне логичными.
Все, что повторяется от песни к песне у одного исполнителя (жанр, голос, мелодия, темп и прочие характеристики), откладывается у слушателей в памяти.
Возможно, это одна из причин, по которой мы можем узнавать исполнителей по отрывку одной из песен, даже если никогда ее не слышали.

Но раз человек может таким образом ``запоминать'' исполнителя на слух, выделяя похожие созвучия, то логично предположить, что с точки зрения акустических волн тоже должны выделяться похожие.
А это значит, что после извлечения из песен конкретного исполнителя  характеристических признаков методом, описанным в главе \ref{chapter1}, 
и последующим превращением их в точки некоторого пространства, они окажутся достаточно близкими друг к другу. 
Поэтому мы можем считать характеристиками теги, связь между ними обсуждалась в главе \ref{chapter1}.

Исходя из этих наблюдений, можно сделать предположение, что исполнитель должен обладать теми тегами, которыми обладает большинство его песен.
Значит, если каким-либо образом узнать теги исполнителя, то можно а) продолжить их на новые песни, или же б) корректировать теги существующих песен.
В случае (а) это позволило бы сразу охарактеризовать песню без ее непосредственного тегирования, в случае (б) \ld возможно, 
протегировать песню лучше, так как могут исчезнуть ``лишние'' теги или же появиться ``нужные''.

Пусть у нас есть несколько протегированных песен одного исполнителя. Тогда посчитаем для каждого тега, который встречается хотя бы в одной песне, сколько раз он встречается суммарно во всех этих песнях.
Полученный процесс и есть \emph{переход к исполнителю}. Его результатом является отображенние из тега в частоту его вхождения в множества тегов песет исполнителя. 
Далее можно различными способами, описанными в главе \ref{chapter1}, выбирать для исполнителя наиболее подходящие теги. После того, как нам стали известны теги исполнителя, можно использовать их для 
тегирования его новых песен и для перетегирования уже имеющихся, повышая таким образом точноть (результаты в главе \ref{results}). Последний шаг назовем \emph{переход от исполнителя к треку}.

В итоге получается следующий метод:
\begin{enumerate}
 \item Протегировать несколько песен конкретного исполнителя одним из обсуждаемых в главе \ref{chapter1} алгоритмов.
 \item Осуществить переход к исполнителю так, как описано выше.
 \item Отфильтровать теги исполнителя.
 \item Выполнить переход от исполнителя к треку, либо задав новые теги, либо обновив существующие.
\end{enumerate}

Отметим положительные и отрицательные стороны предложенного метода.

\emph{Плюсы:} 
\begin{enumerate}
 \item В случае больших объемов музыки (например, музыкальная база социальной сети), где на каждого исполнителя приходится много песен, можно добиться ощутимого прироста в точности тегирования.
 \item Если необходимо знать теги всех песен исполнителя, то данный метод требует столько же времени, сколько и тегирование обычным методом всех песен в отдельности.
 \item В худшем случае (всего одна песня на исполнителя) данный метод вырождается в тот алгоритм, которым производилось первоначальное тегирование песни. Иными словами, наша модификация не ухудшит
 изначальный алгоритм тегирования.
\end{enumerate}

\emph{Минусы:} 
\begin{enumerate}
 \item Если необходимо знать теги лишь одной конкретной песни, то все равно требуется тегировать другие, что отрицательно скажется на времени работы алгоритма.
 \item Если музыкальная база содержит мало песен на исполнителя, то метод может не показать своего преимущества.
\end{enumerate}

\section{Формальное описание}

Введем несколько вспомогательных определений.

Как и в главе \ref{chapter1} будем использовать обозначения $S = \{s_1, s_2, \ldots, s_D \}$ \ld некоторое множество песен, $D = |S|$, $ \mcV $ \ld словарь, состоящий из $|\mcV|$ уникальных слов.

Определим \emph{датасет} над $S$ как $\mcD = \{ (\mb{x}_1, \mb{y}_1), \ldots, (\mb{x}_D, \mb{y}_D) \}$ \ld множество пар таких, 
что:
\begin{itemize}
 \item с песней $s_i$ ассоциирован вектор $\mb{x}_i = (x_{1}, \ldots, x_{N})$, где $N$ \ld размерность пространства точек после сужения 
 исходного пространства характеристических признаков, \ld некоторая точка в $\R^N$;
 \item $y_i$ \ld семантический вектор песни $s_i$.
\end{itemize}

\emph{Обучающая выборка} \ld датасет над некоторым заранее подготовленном множестве песен, про каждую из которых извесен ее семантический вектор.

\emph{Алгоритм автотегирования} над обучающей выборкой $\mcD$ \ld функция ${\mcA}_{\mcD} : \R^N \rightarrow \R^{|{\mcV}|}_{+}$,
аргументом которой является точка из $\R^N$, ассоциированная с некоторой песней, а значением \ld точка из $\R^{|{\mcV}|}_{+}$ \ld семантический вектор.

Обозначим $\art_p = \{s_1, \ldots, s_{n_p} \}$ множество из $n_p$ песен одного и того же исполнителя.

Определим \emph{семантически вектор исполнителя} $\art_p$ как $\ty^p = (\ty_1, \ldots, \ty_{|\mcV|})$, причем 
$$\ty^p_i = \sum^{n_p}_{j=1} \left [y^j_i > 0 \right ]$$,
где $[x]$ \ld индикаторная функция, $y^j_i$ \ld принадлежность $i$-ого тега $j$-ой песне исполнителя $\art_p$. Иными словами, семантический вектор исполнителя
для каждого тега из $\mcV$ показывает, сколько песен из $\art_p$ обладают этим тегом.
Без ограничения общности будем считать, что $\forall i: \ty^p_i \gte \ty^p_{i+1}$, то теги упорядочены по неубыванию значений в семантическом векторе исполнителя.

Назовем процесс построения семантического вектора исполнителя \emph{переходом к исполнителю}.

Определим функцию $$count(\mb{y}) = \sum^{|\mcV|}_{i=1} [y_i > 0]$$,
показывающую, сколькими тегами протегирована песня, соответствующая $\mb{y}$.

Зафиксируем некоторый алгоритм $\mcA = \mcA_{\mcD}$ над некоторой обучающей выборкой $\mcD$, причем $count(\mcA(\mb{x})) = C, \forall x \in \R^N$,
то есть алгоритм всегда











